1. Компіляція та інтерпретація коду. Переваги та недоліки цих підходів. Похідний код, машинний код, байт-код. JIT-компіляція.
    - Компіляція це переклад прогрми з програмного коду у машинний з нуликами та одиничками. Цей код зберігається у файлі та може виконуватись тільки на тій ос під яку зроблен. Застосунок для віндовса з інтел на кіск архітектурі не запуститься в мене на маці з м1
    - Інтерпретація це построковий переклад програмного коду у машинний за допомогою інтерпретатора. Зазвичай інтерпретатор відразу розуміє у який машинний код інтерпретувати, тому такі застосунки можуть запускатися будь-де за наявності інтерпретатора
    - Швидкість роботи скомпільований застосунків набагвато вища за швидкість роботи застосунків, що інтерпретуються, але як я вже казав запускати їх досить складно. Крім цього на етапі компіляції можуть бути знайдені помилки у програмі та їх можна буде відразу виправити. Зазвичай неправильний код навіть компілюватися не буде. Під час інтерпретації такий ніби перевірок нема, тому можуть виникнути різноманітні помилки. 
    - Похідний код - це код на якому пишуть програмісти. Машинний код - це нулики та одинички які розумія перний процесор. Байт код - це хитрість деякий мов програмування, джава одна з них. Програмний код компілюється у байт код та потім виконується віртуальною машиною. Це дозволяє досягти кросплатформеності та високої швидкодії. JIT-компіляція або just in time, це один із засобів досягання високої швидкодії. Програма компілюється під час її виконання і після компісяції має дуже високу швидкість, до тих пір вона інтерпретується і виконується. Тому вона кросплатформена, виконується відразу та після компіляції ще й швидко.
2. Основні характеристики мови Java та платформи Java. Переваги/недоліки у порівнянні з іншими мовами/платформами.
    - Джава це об'єктно орієнтована мова, що і є дуже великим плюсом. Це дозволяє писати дуже великі застосунки дуже структуровано та зручно. В джаві є "сміттєвоз" який автоматично чистить пам'ять від непотрібний об'єктів. Це робить її доволі зручною та простою. Але за це ми платимо швидкодією, джава не буде швидше правильної програми на C або C++, але вона трохи не призначеня для цього. Джава кросплатформена та це досягається завдяки віртуальної машини джава. Застосунки на джава компілюються у байткод, який розуміє jvm та може запускати його на будь якому пристрої. Присутня jit компіляція та більшість помилок у правильній програмі можна виявити ще не етапі компіляції. Джава строготипізована, що позбавляє дуже великої кільності проблем з типами та їх перевірками.
3. Примітивні типи у Java: розмір, діапазон. Літерали.
    - У джаві є
        - boolean
        - byte
        - int 
        - long
        - float
        - double
        - char
        - short
    - Всі чисельні типи окрім char мають від'ємні значення.
    - Цілочисельні типи займають
        - byte - 1 байт - 2^8 ліворуч на половину, нуль, праворуч на половину-1
        - short - 2 байта
        - int - 4 байта
        - long - 8 байт
        - char - 2 байта
    - Числа з плаваючою комою займають доволі складні структурно. Вони поділені на кілька частин 
        - Число або мантиса
        - Степінь двійки
    - Межі 
        - float 3,4028е38
        - double 1.79769313e308
    - Літерали
        - Чисельні літерали
            - щоб використовувати long тип данних треба додати у кінці L
            - Числа можна писати у шістнадцятковій системі якщо додати на початку 0x
            - Числа можна писати у вісімковій системі якщо дописати 0
            - Двійкова - 0b
            - Double - D
            - float - А
            - boolean вказувати тільки малими літерами
        - Символьні
            - \b - backspace
            - \t - tab
            - \n - new line
            - \f кінець сторінки
            - \r перевод каретки
4. Класи-обгортки для примітивних типів.
    - Кожному з примітивів відповідає свій клас обгорткі. Це ніби той самий примітив але вже у вигляді класу. В них містяться константи їх розміру, Конструктори з їх примітиву або рядка, корисні методи для роботи з цими примітивами: порівняння, переклад у інші типи даннх, переклад у різні системи числення та багато іншого. Ці класи зазвичай використовуються через їх корисні статичні методи, для перкладу або  порівняння та у механізмі боксингу та анбоксинку. Коли ми наприклад використовуємо колекції з класами та кладемо туди не клас а просто примітив, то він пакується у свій клас огортку та кладеться до колекції, так само якщо ми в примітив будемо писати значення з колекції, ми будемо читати класс, перекладати його в примітив та записувати.
5. Система числення. Запис цілочисельних літералів у різних системах числення у Java. Перетворення літералів з однієї систему числення у іншу.
    - Крім звичній всім нам десяткової системи числення існує багато інших. Загалом система числення працює так. Порядок помножити на число системи в тепені цього порядку. Тобто двійкове число 10101 це 2 у 0 + 2 у 2 + 2 у 4 тобто 16 + 4 + 1 або просто 21.
    - У джаві є двійкова, вісімкова, десяткова та шістнодцяткова системи числення. Для того щоб записати число в певній системі числення треба використати на його початку спеціальне позначення. 
        - Двійкова - 0b
        - Вісімкова - 0
        - Десяткова за замовчуванням
        - Шістнадцяткова - 0x
    - У пам'яті все це зберігається однаково, але якщо треба щоб в нас було саме представлення числа в певній системі - можна використати метод класу огортки 
6. Двійковий та додатковий двійковий код.
    - Оскільки комп'ютер складається з напівпровіднийків, у який 2 стани: ток є та току нема, вся інформація у комп'ютері представлена у двійковому коді. Все це представлено у двійковій системі. Її розуміння ґрунтується на одному простому правилі: після 1 іде 10. Щоб просто перекласти з двійкової системи число у десяткову, треба знайти всі одинички та запам'ятатий їх порядки(найбільш права - нульовий порядок), потім взяти сумму двійок у степені цих порядків. За допомогою цього можна доволі просто представляти додатні числа. 
    - Додатковий двійковий код це спосіб представлення від'ємний чисел у комп'ютерах. щоб отримати двійковий код певного числа, треба інвертувати всі числа та потім додати одиницю. Одий це 00000001 тоді -1 це 11111111.
7. Оператори. Пріоритети операторів.
    - ++, —	 постинкремент, постдекремент	 справа налево
    - ++, —, +, -, ~, !	 преинкремент, предекремент, унарный плюс, унарный минус, поразрядное дополнение, булево «не»	 справа налево
    - *, /, %	 умножение, деление, остаток от деления	 слева направо
    - +, —	 сложение, вычитание	 слева направо
    - <<, >>, >>>	 сдвиг влево, сдвиг вправо, беззнаковый сдвиг вправо	 слева направо
    - <, >, <=, >=, instanceof	 меньше, больше, меньше или равно, больше или равно, сравнить тип	 слева направо
    - ==, !=	 равно, не равно	 слева направо
    - &	 битовое «и»	 слева направо
    - ^	 исключающее «или»	 слева направо
    - |	 битовое «или»	 слева направо
    - &&	 логическое «и»	 слева направо
    - ||	 логическое «или»	 слева направо
    - ?:	 тернарный оператор	 слева направо
    - =, +=, -=,*=, /=, %=, &=, ^=,  |=, <<=, >>=, >>>=	 операторы присваивания	 справа налево
8. Арифметичні оператори. Оператори інкременту  та декременту. Різниця між предінкрементом та постінкрементом.
    - преинкремент	++	cout << ++value;	Значение в переменной value увеличивается, после чего оператор cout печатает это значение
    - предекремент	—	cout << —value;	Значение в переменной value уменьшается, после чего оператор cout печатает это значение
    - постинкремент	++	cout << value++;	Оператор cout печатает значение переменной value, затем увеличивает это значение на 1
    - постдекремент	—	cout << value—;	Оператор cout печатает значение переменной value, затем уменьшает это значение на 1
9. Логічні оператори. Короткозамкнуті логічні оператори. Оператори зсуву. Арифметичний та логічний зсув.
    - Логічні оператори це ніби операції булевої алгебри. Побітові операції виконуються послідовно з кожним бітом. Операторі зсуву зміщують біти. Якщо це зсув ліворуч, то новий біз заповнюється нулем, Число прицьому ніби множиться на 2.
    - Існує 2 зсува ліворуч. Арифметичний та логічний. Під час арифметичного зсуву знаковий біт копіюється, під час логічного зсуву біт заповнюється нулем
10. Перетворення типів. Явне та неявне перетворення типів. Можливі втрати точності та значущості при перетворенні типів.
    - Під час виконання операцій над двоматипами - вони перетворюються на одийн. Перетворення може бути явним, коли программіст вказує це та неявним, це робить компилятор за нас. Під час явного перетворення можлива втрата значущості та точності(число 1000 перекласти у байт точно неможливо та воно буде викривлено) інколи точність більш низький порядків буде встрачена, але число залишиться приблизно таким самим.
    - Неявне перетворення. якщо хоча б щось дабл - все у дабл. Якщо хоча б щось флоат - все у флоат. Якщо хоча б щось лонг - все у лонг. А так просто у інт.
    - Явне перетворення виконується так як сказав программіст
11. Структурне програмування. Основні принципи та конструкції. Блок-схема алгоритму (Flowchart).
    - Структурне програмування - розробка програмного забезпечення на основи представлення програми у вигляді ієрархічної структури блоків. Основні конструкції - послідовне виконання виконання за умовою та цикли.
    Один з основних принципів - не повторяти свій код. Також, в блок є один вхід та може бути кілька виходів. Ще один принцип - проектування згори донизу, від більш абстрактної картинки до бильш конкретних деталей. Блок - це логічна частина програми. Змінні які з'явились всередині блока видно тільки всередині цього блока. У блоці можуть бути інші блоки, блок можна вважати однією частиною, яка робить щось одне. Основні конструкції: оператор if. Якщо умова іфа правдива - виконувати його тіло. Також існує тернерний оператор який дозволяє записувати у змінну первне значення в залежності від умови. Якщо в нас дуже багато варіантів умов - то можна використовувати switch caseи конструкцію. це дуже зручно робити з enum. Існує 3 вида циклів. фор, який складається з ініціалізації, тобто частини яка виконується перед початком, умови виконання циклу та дій після кожної ітерації, тіла циклу. Кожна з цих частин може бути порожньою. Цикл вайл складається з умови його виконання яка перевіряється перед заходом у ітерацію та самого тіла циклу. конструкція ду вайл це ніби вайл але перевірка умови відбувається після ітерації. Для більш зручної роботи з циклами використовуєтються брейк, тобто вихід з циклу, контінью, тобто перехід на наступну ітерацію та мітки, щоб робити те саме але зі вкладеними циклами.
12. Блоки. Область видимості змінних. Локальні змінні та змінні, що задекларовані на рівні класу. Перекриття області видимості. 
    - Блок - це логічна частина програми. Змінні які з'явились всередині блока видно тільки всередині цього блока. У блоці можуть бути інші блоки, блок можна вважати однією частиною, яка робить щось одне. Локальні змінні не можна перевизначати всередині блока, а змінні рівня класу - можна. 
13. Конструкції управління потоком виконання. if, if-else, ланцюжки if-else if-else if... . Конструкція switch 
    - оператор if. Якщо умова іфа правдива - виконувати його тіло. Також існує тернерний оператор який дозволяє записувати у змінну первне значення в залежності від умови. Якщо в нас дуже багато варіантів умов - то можна використовувати switch caseи конструкцію. це дуже зручно робити з enum
14. Конструкції управління потоком виконання. Цикли for, while, do-while, for-each. continue та break. Мітки.
    - Існує 3 вида циклів. фор, який складається з ініціалізації, тобто частини яка виконується перед початком, умови виконання циклу та дій після кожної ітерації, тіла циклу. Кожна з цих частин може бути порожньою. Цикл вайл складається з умови його виконання яка перевіряється перед заходом у ітерацію та самого тіла циклу. конструкція ду вайл це ніби вайл але перевірка умови відбувається після ітерації. Для більш зручної роботи з циклами використовуєтються брейк, тобто вихід з циклу, контінью, тобто перехід на наступну ітерацію та мітки, щоб робити те саме але зі вкладеними циклами.
15. Пам’ять. Стек LIFO. Використання стеку при створенні локальних змінних та в процесі викликання методів
    - Стек це структура данних що працює за принципом last in first out. У стек можна покласти елемент да дістати елемент з нього. Підчас роботи програми стек використовується для зберігання локальний змінних та посилань на об'єкти, які знаходяться у купі. під час виклику певного метода, у стек записуються його аргументи та куди треба повернутись після виконання цього метода.
16. Пам’ять. Купа (Heap). Об’єкти та посилання на об’єкти. Збирач сміття (Garbage Collector)
    - Всі об'єкти створені у джаві зберігаютсья у купі. Це така величезна частина пам'яті у якій створюються об'єкти. Щоб мати доступ до певного об'єкта, треба мати посилання на нього, інакше його буде неможливо там знайти. Якщо в нас нема посилання на певняй об'єкт, ми вже його не зможемо знайти та не зможемо його використовувати. Він стає зайвим, та спеціальна частина джава, яка називається garbage collector збирає та видаляє такі об'єкти. Посилання на об'єкти можуть зберігатися у інших об'єктах або у стеці.
17. Масиви. Декларування, створення, ініціалізація, використання.
    - Масиви використовуються для зберігання однотипних данних. Масиви є об'єктами тому зберігаються тільки у купі. Ми працюємо з ними за допомогою посилань на них. Важливо пам'ятати,що якщо змінювати масив через посилання, то змінюється оригінал у всіх. У масива є дуже важлива характеристика - його розмір, це максимальна кількість елементів що можуть бути у масиві одночасно. Елементи масива можна отримати за їх індексом у цьому масиві. Відлік почінається з нульового елемента. Якщо спробувати зробити будь які дії з елементом який не є у масиві(взяти делятий елемент у масиві на 5 елементів) то ми отримаємо index out of bounds exception. У різних мовах програмування це по різному працює. Наприклад у с++ нічого не буде і ми отримаємо щось незрозуміле. Розмір масиву змінити не можна. Масив декларується за допомогою квадратних скобачєк. Створити масив можна задавши його розмір, тоді елементи в ньому будуть заповнені значеннями за замовчуванням. Можна проініціалізувати масив відразу при створенні або після створення надати значення кожному елементу. 
18. Основні поняття ООП. Абстрагування, інкапсуляція, успадкування, поліморфізм.
    - Абстрагування це виділення важливих частин та приховування незначних
    - Інкапсуляція - об'єднати данні та методи для роботи з ними. Приховати данні звузивши область видимості та надати тільки ті використання їх, які нас задовільняють
    - Успабкування - передача вевних рис одного класу іншому. Якщо в нас є людина, то дроворуб успадковує всі риси людини та має свої унікальні дроворубальні риси. У джаві можна успадковуватись тільки від одного класу.
    - Поліморфізм - використання вевних класів об'єднаних одним інтерфейсом або батьківським класом не знаючи конкретності кожного з них.
19.  Відношення IS-A та HAS-A. Оператор instanceof. 
    - Відношення is a виконується між об'єктом та тим від кого він наслідується. Дроворуб is a людина. Відношення has a виконується між елементом та однією з його частин. Людина has a легені, дроворуб has a сокира. instanceof повертає true, якщо те що ліворуч is a те що праворуч. Дроворуб instanceof людина поверне true
20. Класи та об’єкти. Поля, методи та конструктори. Заміщення (override) та перевантаження (overload) методів.
    - Класи це ніби креслення за допомогою якого створюються об'єкти. Об'єкти це певні структурні одиниці які за правилами повинні виконувати певну конретну задачу. У класів є поля, це ніби змінні які належать класу. Минує дуже важливий модифікатор static, який відв'язує метод або поле від об'єкту. Статік поля знаходяться у класі а не у об'єктах цього класу. Також у класів є методи, це певні набори дій які можна використовувати. Статичні методи можна викликати в самого класу, не статичні методи повинні викликатися в об'єктів. Для того щоб зробити інстанс класу, потрібно використати констуктор. Це ніби особливий метод, який нічого не повертає, основна задачаякого - зробити об'єкт. Є дефотлні методи, які завжди неявно присутні, якщо інших конструкторів нема, та спеціальні конструктори написані програмістом, які підготавлюють об'єкт для його подальшого використання.Заміщення - це перевизначення певний методів у їх нащадках. можна перевизначити метод, щоб він більш коректно працював у контексті певного класу. Перевантаження це наявність методів з однаковою назвою, але з різною сигнатурою. Метод який викликається насправді обирається за допомогою арогументів, які передаються такому методу. Двох методів з однаковою сигнатурою бути не може.
21. Модифікатори області видимості. Правила зміни модифікаторів області видимості при заміщенні методів (override).
    - Існує кілька модифікаторів області видимості, які обмежують доступ до певних частин програми. 
        - Приватні речі видно тільки з того самого класу. 
        - Речі без модифікатору або з дефолтним модифікатором видно з того ж пакету.
        - Протектид речі видно ще й за класід нащадків
        - Публічні речі бачить будь-хто
    - При успадкування певного класу та перевизначення його методів, область видимості неможна звужувати, бо тоді в нас не зовсім буде виконуватись is a якщо ми не будемо бачити один з методів
22. Статичні та нестатичні поля та методи.
    - Модифікатор статік прив'язує методи та поля до класа, за допомогою цього їх можна використовувати ці поля та методи без створення інстанса. На статік не працює поліморфізм, можна змінювати поля та використовувати методи з об'єкту або з самого класу. з об'єкту краще не треба. 
23. Процес створення нових об’єктів за допомогою оператора new (начальна ініціалізація полів, конструктори, статичні та нестатичні блоки ініціалізації).
    - Спочатку клас шукається у пам'яті, якщо його нема то він туди завантажуєтсья. Потім до першого його використання виконується статік частина ініціалізації, у якій як правило ініціалізуються файнал поля та записується значення за завовчуванням для не файнал полів. Потів виділяється пам'ять під новий об'єкт. Виконується нестатичний блок ініціалізації та ініціалізуються не статичні поля або значенням за замовчуванням або вказаним заздалегідь. Викликається потрібний конструктор, у ньому або неявно викликається конструктор за замовчуванням балька або программіст сам його вказує. Виконується застина ініціалізації баться так само як і тут та потів виконується цей конструктор. Після того як код у конструкторі відпрацював повертається посилання на створений інстанс.
24. this, super.
    - this це посилання на об'єкт у якому ти зараз знаходишся. За допомогою this можна викликати методи та отримувати доступ до змінних всередині цього класу. Метод this() це насправді конструктор і його можна викликати у конструкторах якщо. Оскільки можна перевизначати змінні рівня класу, доступ до ций змінний зазвичай робиться через this. super це посилання на батьківський клас з поточного. Зазвичай super використовується для виклику батьківського конструктора під час ініціалізації, також super використовується для доступу до методів та полів батьківського класу(якщо вони хоча б протектид). Звісно з статичного поля чи методу this працювати не буде.
25. Пакети. Імпортування класів. Статичне імпортування.
    - Пакети допомагають організувати структуру програми та уникнути конфлікту імен. Пакети можуть у собі містити класи,  інтерфейси та інші пакети. Зазвичай назва пакету починається зі зворотнього домена компанії. Щоб використовувати вевний клас треба або кожен раз писати повний пакетний шлях до нього або імпортувати його. Імпортування працює на етапі компіляції та потім замінюється на повне ім'я. Можна використовувати статичне імпортування для того щоб імпортувати не всі класи загалом, а тільки їх статичні методи
26. Способи створення констант: final та enum. Переваги та недоліки цих підходів.
    - Файнал поля не можна змінювати пістля ініціалізації, тому такі поля можна використовувати для зберігання констант. Константу можна записати як public static final int і ім'я константи. Оскільки ми використовуємо інт нам може надатися інт константи якого в нас нема. Щоб такого не було можна використовувати енами. Енам це особливий клас, який не може розширювати класи. Ми задаємо константи та можливо додаткові параметри для них, вони будуть зберігатися та при використанні будуть створені тільки одиничні об'єкти для кожного енаму. Також компілятор перевіряє, щоб було надано тільки енами які існують. Дуже зручно використовувати енами для зберігання значень представлення певного значення у вигляді бітових рядків. У кожного енаму ім'я та 1 здвинута праворуч на певну кількість розрядів тоді можна викори стовувати побітові операції для представлення чогось.
27. Абстрактні класи. Відмінності у порівнянні з інтерфейсами та звичайними класами.
    - Абстанкний клас це ніби заготовка від якої буде наслідуватись інші класи, використовується модифікатор abstract. Конструктор такого класу неможливо викликати за допомогою new, тільки як super при створенні нащадку. У абстактному класі можуть бути звичайні методи які можна буде визивати з нащадка та абстракні методи які нащадок обов'язково повинен перевизначити. Оскільки це клас, можна буде успадкувати тільки його. На відміну від інтерфейсів, де є тільки оголошення певних методів. Можна успадкувати багато інтерфейсів та у ний не може бути конкретний методів. Також в них нема конструкторів.
28. Шаблон проектування «Стратегія».
    - Шаблон проектування або просто паттерн це best practicise або просто найкраще рішення певної задачі, розумні дядьки зібрались та придумали їх. Паттерн стратегія дозволяє обрати певний алгоритм для виконання задачі. У змінну записується те що реалізовує інтерфейс того що ми будемо використовувати. Та потім просто використовуємо один з алгоритмів.
29. Принципи SOLID.
    - Солід це найголовніші прийципи об'єктно орієнтованого програмування. 
    - Single responsibility principle В класу повинна бути тільки одна задача та не повинно бути більше однієї причини його змінювати.
    - open closed principle існує 2 інтерпритації цього принципу. загалом він звучить так Software entities ... should be open for extension, but closed for modification. Це означає що ми повинні писати класи, поведінку яких можна змінювати без рекомпіляції коду. Інша інтерпретація відноситься до поліморфізму.
    - Liskov substitution principle. Клас нащадок повинен працювати так само як і клас від якого успадкувавля а не повністю змінювати поведінку. Якщо батько гріє, нащадок не повинен охолоджувати. І те що використовує батька, повинно використовувати ще й всіх нащадкій не знаючи цього.
    - Interface segregation principle. Код не повинен додавати методи які не будуть використовуватися. Інакше краще один величезний інтерфейс розбити на купу маленьких. 
    - Dependency inversion principle. Клас повинен залежати від більш абстрактних речей а не від контретних. Це зменшує каплінг.
30. Клас Object.
    - Клас від якого неявно успадковуються усі інші класи. В нього є метод equals та hashCode які треба перевизначати тільки разом. Метод для пердставлення об'єкту у строковому вигляді, метод для клонування та отримання класу класу. 
31. Клас String.
    - Клас стрінг представляє усі рядки у джаві, він іммутабл. Операція контатенації насправді створює новий об'єкт на основі вже існуючих. Також не можна створити нащадків цього класу бо тоді можна буде поламати потовину джави з кривими руцями. Якщо треба багато змілювати якийсь рядок, то треба використовувати string buffer або string builder, які є мутабл та в них можна легко та швидко створти потрібний рядок. Рядок собою представляє масив символів. Також має у собі дуже багато різноманітних методів
32. Алгоритм сортування бульбашкою.
    - Найпростіший та один з найбільш повільших алгоритмів сортування. Ми ітеруємося по массиву у двох циклах та порівнюємо наш елемент з наступним. Якщо вони не відсортовані - міняємо їх місцями.
33. Алгоритм сортування вибором.
    - Знаходиму у масиві найменше або найбільше значення та ставимо його на початок, повторюємо те саме але опускаємо елемент який ми тільки но переставили.
34. Алгоритм сортування включенням.
    - Ми по порядку обираємо елементи та ставимо їх на їх відсортоване місце. Елементи беремо з невідсортованої частини масиву
35. Інтерфейси. Відмінності у порівнянні з абстрактними класами.
    - Інтерфейс це ніби контракт того чого клас може робити. У інтерфейсі може бути лише декларація методів та константи, конструкторів та конкретних методів бути не може також неможна створити інстанс інтерфейсу. Можна імпліментувати будь яку кількість інтерфейсів.
36. Collection framework. Основні інтерфейси та класи.
    - Колекції призначені для зберігання данних. На відміну від массивів, у колекції можуть бути лише посилання на об'єкти. Основні інтерфейси: Collection, Set, SortedSet, List, Queue, Deque. Collection це базовий клас для усіх колекцій. У коллекцію можна додавати та видаляти елементи. Можна перетворити у массив, додати у коллекцію іншу коллекцію.
37. Інтерфейс Iterator. Використання ітераторів та циклів for-each для перегляду елементів колекцій.
    - Використовується для перегляду елементів у коллекції. Має метод на перевірку чи є наступний елемент, метод отримання наступного елементу та видалення поточного елементу. Отриматя ітератор можна викликавши метод interator. В кожної коллекції своя реалізація цього методу для поліпшення роботи з різними классами. Ітератор можна використовувати явно або неявно за допомогою конструкції for-each. 
38. Типізовані та нетипізовані колекції.
    - Колекції використовують дженерік типи. За допомогою них можна створювати типізовані колекції. Ми задаємо дженерік тип та компілятор за нас буде робити усі перевірки, доб ми правильно все використовували. Нетипізовані коллекції потребують постійний перевірок на тип того що ми звідти дістаємо. По суті нетипізована колекція у собі є типізованою з типом Object.
39. Інтерфейс List. Класи ArrayList та LinkedList: переваги та недоліки. Інтерфейс RandomAccess.
    - Ліст це найпростіша колекція. Це просто список елементів. Можуть бути  дублікати та null. Порядок перегляду елементів у лісті такий самий як і при додаванні. Також має додаткові методи додавання, змінення, видалення та перегляду за індексом. Arraylist маж всередині себе массив, Та маркерний інтерфейс randomAccess, який означає що ми можемо отримати елемент зі швидкістю О1. Методи get та set працюють дуже швидко, але додавання та видалення елементів з середини призводить до її зсуву. Додавання елементів в кінці швидке але якщо ще є незайняті комірки. Коли вони всі заповнюються - створюється новий масив, перекопійовуються значення та додається. Тому можна задати величину масиву вручну якщо в нас там буде багато елементів. LinkedList - має двобічну зв'язність та ми можемо задавати порядок перегляду елементів. Не реалізує randomaccess бо туде повільно беруться та змінюються елементи за індексом. додавання та видалення працює дуже швидко. В кожного елемента такого списку є посилання на наступний та на попередній елементи.
40. Інтерфейс Set. Клас TreeSet. Двійковий та лінійний пошук. Інтерфейси Comparable та Comparator.
    - У множині не може бути дублікатів. Можна використовувати тільки для іммутабл об'єктів. Усі методи з інтерфейсу колекції але ще й контракт на унікальність. Порядок елементів не гарантується. У загальному випадку цей інтерфейс використовує у собі мапу та звертає увагу тільки на ключі. Трі сет представлений у вигляді двійкового дерева, де зліва від кореня те що його менше а зправа те що більше. Двійковий пошук працює на відсортованих данних. Ми беремо серединку та перевіряємо з якого боку має бути наш елемент. далі беремо серединку того простору и так далі. Лінійний пошук це просто перебір попорядку всіх можливих значень доки не знайдемо шукане. У трі сеті використовується двійковий пошук по дереву. Перевірка виконується або за допомогою реалізації інтерфейсу comparable і визначення методу compare to або за допомогою comparatorа який порівнює 2 елементи та каже що більше а що менше. Программіст має або перевизначити compara to або написати свій компаратор.
41. Інтерфейс Set. Клас HashSet. Хешування. Хеш-функція. Методи hashCode() та equals(). 
    - Клас Хеш сет працює як сет але гарантує відсутність дублікатів за допомогою хеш коду. Працювати можна тільки з іммутабл об'єктами. В об'єктів має бути перевизначено equals та hashCode. Хеш-функція це метод отримання хеш коду певного об'єкту в залежності від його стану. Хешування це спосіб швидкого пошуку, коли на основі хешу об'єкту ми отримаємо його номер та кладемо його в певне місце яке називається бакетом. метод equals має бути відношенням еквівалентності та може бути порівниння з null. Хешкод двох однакових за equals об'єктів має бути однаковим та хешкод одного об'єкта в одному і тому самому стані має бути обнаковий. та бажано щоб в двох різних об'єктів був різний хеш код.
42. Внутрішня реалізація сховища HashSet. Capacity та Load Factor. 
    - Хешсет всередині це просто хешмап де ми використовуємо тільки ключі. Коли ми додаємо елемент до хешсету, вираховується його хеш код та знаходиться його бакет і він туди кладеться, якщо там вже є якийсь елемент, ми перевіряємо його за equals і якщо це не той самий елемент - додаємо його до linkedліста всередині якого буде 2 наших елементи з одного бакета. Якщо їх занадто багато в одному - табм виросте бінарне дерево для оптимізації пошуку. Коли в двох різних об'єктів однаковий хеш - це називається колізією та сповільнює програму. Капасіті це кількість наший бакетів, лоад фактор це кількість елементів поділити на капасіті, якщо лоад фактор дуже високий - великий шанс колізій, тому коли він перевищує 0.75(дефолт) в нас збільшується хеш таблиця і там з'являються нові бакети.
43. Асоціативні масиви (Map). Основні поняття: ключ (key), значення (value). Інтерфейси Map, Map.Entry. Класи TreeMap та HashMap.
    - Асоціативний массив це ніби массив пар ключ значення, де по унікальному ключу ми можемо отримати значення. Ці массиви є в інтерфейсі Map. Це дженерік тип, де ти вказуєш тип ключей та значень. У мапи є важливі методи put get та remove, які додають пару, отримують значення та видаляють значення за вказаним ключем відповідно. також можна подивитись чи є такий ключ чи значення, очистити мапу, перевірити скільки там еелментів та чи пуставона. Отримати множину ключей або коллецкію значень. зробити множину записів, додати в одну мапу все з іншої. По суті в мапі лежать мап ентрі, В одного ентрі можна отримати ключ, отримати значення або змінити значення. У трімап ключі це ніби звичайний трісет, кожному ключу відповідає значення а так все працює так як і у трі сеті. хеш так само.
44. Обробка виняткових ситуацій (Exception). Переваги/недоліки у порівнянні з повертанням коду помилки. Exception propagation. Основні конструкції: try-catch, try-finally, try-catch-finally, try-with-resources. 
    - Коли в программі стається ситуація яка не є нормальною послідовністю виконання, наприклад при спробі прочитати файл цей файл було видалено і ми намагаємося прочитати неіснуючий файл - в нас станеться ексепшн. Раніше функції повертали код помилки, але це не є дуже зручним підходом, до в нас перемішується логіка роботи програми та логіка обробки вийняткових ситуацій, також программісту може бути просто ліньки все це перевіряти. Екшепшн перериває послідовність виконання программи та летить нагору доки його хтось не впіймає. Це називається exception propagation. Щоб впіймати ексепшн треба використовувати конструкція трай кетч. У блоці трай ми пишемо потенційно небезпечний код, а у блоці кетч ми ловимо певну вийняткову ситуацію та оброблюємо її. Це дозволяє відокремити обробку вийнятків та логіку, що робить код більш читабельним. Існує також блок файналі, який буде виконано і у випадку роботи программи і у випадку вийнятнової ситуації. Наприклад при роботі з потоками вводу - виводу, де треба закрити потік не зважаючи на можливі помилки. У такому випадку взагалі краще використовувати конструкцію try-with-resources, де ми перечислюємо ресурси які нам потрібні. Вони мають бути або closable або autoclosable і після компіляції це перетвориться на їх закривання разом з можливими помилками закривання.
45. Класифікація виняткових ситуацій: Throwable, Error, Exception, RuntimeException. Контрольовані (checked) та неконтрольовані (unchecked) виняткові ситуації.
    - Взагалі усе що можна викинути успадковується від класса throwable. А саме класи error та exception. Зазвичай нема сенсу ловити error, бо коли машина горить не треба вже намагатися закрити віконце. Eroor це типо стак оверфлоу або аут оф меморі. З ексепшна успадковуються зазвичай чекд ексепшни та рантайм екссепшни. Тантайм ексепшни це виключення які мій випадково зробити программість через приві руці, по типу indexOutOfBoundsException. Існують контрольовані та неконтрольовані ексепшни. Некотрольовані ексепшни це зазвичай рантайм ексепшни. Контрольовані ексепшни потрібно обов'язково відловлювати або повідомляти,що цей метод може викинути такий ексепшн. 
46. Декларування (throws) та викидання (throw) виняткових ситуацій. Зміна декларацій виняткових ситуацій при заміщені методів.
    - Декларування throws повідомляє що цей метод може викинути такийто ексепшн, а самме throw викидає ексеппшн. При наслідуванні за 3 принципом солід не можна узагальнювати ексепш та додавати нових ексепшнів
47. Ввід-вивід даних. Блокуючий та неблокуючий ввід-вивід. Потоки вводу-виводу. InputStream, OutputStream, Reader, Writer.
    - У джаві є бібліотеки io, які використовується для роботи з потоками. у бібліотеці io блокуючі класи, у nioнеблокуючі, у nio 2 асинхронні. У бібліотеці io для читання використовуються input stream якщо нас цікавлять байти та reader якщо символи. Якщо ж ми пишемо - треба брати outputstream для байтів та writer для символів. Самі ці класи - абстрактні, в них нема конкретний методів для читання, але їх нащадки вміють працювати з певними потоками. Загалом inputstream вміє читати або один байтик або у певний буфер. Можна ставити мірки та потім повертатися до них, але то вже інша історія. Загалом read повертає інт але ж читає він байт. він поверне -1 якщо в нас кінець файлу. Для того щоб писати програми з високою швикодією, треба використовувати буферизацію, де ми читаємо у буфер та потів вже з нього беремо данні. OutputStream пише байтики. В нього є метод write, який пише байтик або з масиву. Також є метод flush для того щоб примусово записати. Для читання символів ми використовуєсо reader, в якого ми можемо прочитати символ або прочитати символи у буфер. Пишемо ми через writer де можна писати символ або масив символів. Ці читалки можна об'єднувати у цепочки перетворень, наприклад користувач пише на клавіатурі у стандартний потік вводу, ми читаємо звідти за допомогою inputstreamreaderа символи, які передаємо у bufferedReader щоб читати відразу рядки.
48. Фільтри. Їх використання з потоками вводу-виводу.
    - Фільтри дозволяють трохи змінювати потік з якого ми читаємо. Один з найпростіших прикладів - фільтр який конвертує всі пробіли на підкреслення коли ми читаємо. Цей клас повинен успадковуватись від класа FilterReader. Їх зазвичай використовують у ланцюжках вводу виводу. Наприклад ми читаємо зі стандартного потоку вводу за допомогою inputStreamReader передаємо символи які там прочитали у фільтр та робимо якісь зміни з потоком та передаємо їх у bufferedReader щоб читати відфільтровані рядки
49. Серіалізація об’єктів. Інтерфейс Serializable. transient-поля. Версії.
    - Серіалізація - це процес представлення первного об'єкту у викляді файлу. Для того щоб представити так файл нам потрібно щоб він та все що у ньому використовується імплементувало serializable, у цьому нам може допомогти модифікатор transient, який робить так, що все що помічене ним не буде враховуватись у серіалізації. Також, можливо, що програма змінилася та класс було переписано, тоді ми не зможемо дисеріалізували файл який було зроблено за старої версії файлу, бо коли той файл було створено наш клас виглядав інакше. 
50. Networking. Організація клієнт-серверної взаємодії. Socket API. Класи Socket, ServerSocket. 
    - Існує мерева модель osi яка поверхнево описує зваємодію двох пристроїв. Ця взаємодія відбувається на 7 рівнях. Найвищий рівень - рівень Application, до якого входять високорівневі api які дозволяють працювати не зважаючи на деталі. Цей рівень використовує рівень presentation, який перекладає інформацію з протого нашого уявлення на інформацію готову до передачі. Далі цей рівень використовує рівень session який відпдвідає за передачу та прийом інформації з певного джерела, сесія зазвичай тривала. Цей рівень використовує рівень transport який здатен передавати інформацію між різними частинами мережі. Цей рівень використовує рівень network який дозволяє передавати данні по структурованій мережі з багатьма нодами, прокладаючи шлях з різних її частин. Цей рівень використовує рівень Data link який здатен передавати данні між двома нодами, зв'язаними якоюсь апаратною частиною. Цей рівень використовує рівень phusical який здатен передавати чисті байти через апарати. Передаються загалом пакети. Кожен рівень додає до початкових данних свій хедер. Та кожен рівень не знає що його хтось використовує. Інша модель представлення цього це tcp/ip у якій 4 рівні. IP - це internet protocol в якого є 2 версії ip v4 та ipv6. Перша більш застаріла в неї 32 розряди, а у нової 128. localhost або більш відомий як адресса 127.0.0.1  це адреса поточної машини. При передачі певної інформації в апаратної частини є свій mtu або maximum transmission unit або максимальна величина пакету який може бути відправлений. ip адреса це ніби адреса мережі та адреса хотса у ній. Оскільки людям зручніше сприймати слова а не байти, було придумано dns або domain name system. Це ніби буквене представлення певної ip адреси. Наприклад якщо в нас dns ім'я таке
    java.oop.google.com - при спробі отримати доступ ми підемо до серверу com та запитаємо в нього де знайти google, далі нас буде перенаправлено до google, в якого ми спитаємо де знайти oop, він нас перенаправить до oop і в нього ми знайдемо де шукати java і тоді вже ми дійдемо до кінйя. Існує 2 методи передачі tcp та udp. tcp це ніби важлива розмова двох людей які будуть перевірячи чи людина чує вас чи ні. Через ці перевірки це буде працювати трохи повільніше. udp це ніби спікер дає промову. Йому не важливо, щоб кожна людина його почула, він просто дає інформацію до всіх, через це це працює швидше, але цей механізм не дуже надійний. Можлива ситуація коли на одній фізичній машині 2 різні программи хочуть отримувати данні з мережі, тоді тут використовується порт. Адреса ком'ютера це його ip а саме сервіс який там є це вже порт на цьому комп'ютері. Оскільки в нас обмежена цількість адресів, існує nat та pat. nat це перекладання певного ip сервера на ip пристроя всередині цього сервера. pat це перекладання порта. У програмах використовуються сокети для роботи з усім цим. Сокети надають зручний інтерфейс обміну інформації. У джаві це є у бібліотеці java.net. Socket та ServerSocket використовують tcp, DataagramSocket та DatagramPacket використовують udp. Загалом у tcp сокета такі методи У серверого можна створити на відкрити на певному потрі, отримати звичайний сокет який підключений до клієнта. Клієнт вказує ip та port щоб під'єднатись до сервера. Далі сервер може надсилаті клієнту, який буде це все отримувати, і навпаки. У джаві ми отримаємо input stream та output stream за допомогою get... те що сервер пише у output клієнт читає з input та навпаки. 